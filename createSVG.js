import {feature} from 'topojson';
import {geoProject} from 'd3-geo-projection';
import {geoConicConformal, geoPath, geoIdentity} from 'd3-geo';
import fs from "fs";
import commander from "commander";

commander
    .version(require("./package.json").version)
    .usage("[options] [file]")
    .description("Convertit une topologie vers un SVG")
    .option("-o, --out <file>", "output file name; defaults to “-” for stdout", "-")
    .option("-w, --width <value>", "output width", 960)
    .option("-h, --height <value>", "output height", 500)
    .option("-p, --precision <value>", "number of output digits after the decimal point", 6)
    .option("--fill <value>", "default fill", "none")
    .option("--stroke <value>", "default stroke", "black")
    .option("-r, --radius <value>", "default point radius", 4.5)
    .parse(process.argv);

const topology = fs.readFileSync(process.argv[1]);
const WIDTH = +process.argv[2];
const HEIGHT = +process.argv[3];

var reader = read(commander.args[0], writeTopology).then(end).catch(abort),
    writer = write(commander.out),
    path = d3.geoPath().pointRadius(function(d) { var p = d.properties, v; return p && (v = p["point-radius"] || p.pointRadius) != null ? v : commander.radius; }),
    render = commander.precision == null ? path : function(d) { return path(d3.geoQuantize(d, commander.precision)); };


writer.write("<?xml version=\"1.0\" encoding=\"utf-8\"?>" + os.EOL
    + "<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">" + os.EOL
    + "<!-- Generated by carte-departements " + require("../package.json").version + ". -->" + os.EOL
    + "<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\""
    + " width=\"" + +commander.width + "\""
    + " height=\"" + +commander.height + "\""
    + " viewBox=\"0 0 " + +commander.width + " " + +commander.height + "\""
    + (commander.fill != "black" ? " fill=\"" + attr(commander.fill) + "\"" : "")
    + (commander.stroke != "none" ? " stroke=\"" + attr(commander.stroke) + "\"" : "")
    + ">" + os.EOL);

function end() {
  return writer.write("</svg>" + os.EOL);
}



function writeTopology(d) {
  let p = d.properties, v;

  // frontieres
  return writer.write("<path ")

  return writer.write("  <path"
      + ((v = d.id) != null ? " id=\"" + attr(v + "") + "\"" : "")
      + (p ? ((v = p["fill"]) != null ? " fill=\"" + attr(v + "") + "\"" : "")
        + ((v = p["fill-rule"] || p.fillRule) != null ? " fill-rule=\"" + attr(v + "") + "\"" : "")
        + ((v = p["fill-opacity"] || p.fillOpacity) != null ? " fill-opacity=\"" + attr(v + "") + "\"" : "")
        + ((v = p["stroke"]) != null ? " stroke=\"" + attr(v + "") + "\"" : "")
        + ((v = p["stroke-width"] || p.strokeWidth) != null ? " stroke-width=\"" + attr(v + "") + "\"" : "")
        + ((v = p["stroke-linecap"] || p.strokeLinecap) != null ? " stroke-linecap=\"" + attr(v + "") + "\"" : "")
        + ((v = p["stroke-linejoin"] || p.strokeLinejoin) != null ? " stroke-linejoin=\"" + attr(v + "") + "\"" : "")
        + ((v = p["stroke-miterlimit"] || p.strokeMiterlimit) != null ? " stroke-miterlimit=\"" + attr(v + "") + "\"" : "")
        + ((v = p["stroke-dasharray"] || p.strokeDasharray) != null ? " stroke-dasharray=\"" + attr(v + "") + "\"" : "")
        + ((v = p["stroke-dashoffset"] || p.strokeDashoffset) != null ? " stroke-dashoffset=\"" + attr(v + "") + "\"" : "")
        + ((v = p["stroke-opacity"] || p.strokeOpacity) != null ? " stroke-opacity=\"" + attr(v + "") + "\"" : "")
      : "")
      + (v = render(d), v ? " d=\"" + v + "\"" : "")
      + ">"
      + ((v = p && p["title"]) != null ? "<title>" + text(v + "") + "</title>" : "")
      + "</path>" + os.EOL);
}

function read(file, callback) {
  var index = -1,
      input = file === "-" ? process.stdin : fs.createReadStream(file);

  function callbackObject(object) {
    return callback(object, ++index);
  }

  return new Promise(function(resolve, reject) {
    var data = [];
    input
        .on("data", function(d) { data.push(d); })
        .on("end", function() { resolve(JSON.parse(Buffer.concat(data))); })
        .on("error", reject);
  }).then(callbackObject);
}

function write(file) {
  var output = (file === "-" ? process.stdout : fs.createWriteStream(file)).on("error", handleEpipe),
      queue = Promise.resolve();
  return {
    write: function(data) {
      return queue = queue.then(function() {
        return new Promise(function(resolve, reject) {
          output.write(data, function(error) {
            if (error) reject(error);
            else resolve();
          });
        });
      });
    },
    end: function() {
      if (output === process.stdout) return queue;
      return queue = queue.then(function() {
        return new Promise(function(resolve, reject) {
          output.end(function(error) {
            if (error) reject(error);
            else resolve();
          });
        });
      });
    }
  };
}
