import topojson from 'topojson';
import d3 from 'd3-geo';
import fs from "fs";
import commander from "commander";
import os from "os";

commander
  .version("1.0")
  .usage("[options] [file]")
  .description("Convertit une topologie vers un SVG")
  .option("-o, --out <file>", "output file name; defaults to “-” for stdout", "-")
  .option("-w, --width <value>", "output width", 960)
  .option("-h, --height <value>", "output height", 500)
  .option("-p, --precision <value>", "number of output digits after the decimal point", 6)
  .option("-f, --fill <value>", "default fill", "none")
  .option("-s, --stroke <value>", "default stroke", "black")
  .option("-r, --radius <value>", "default point radius", 4.5)
  .option("--vfill <value>", "default fill for cities", "black")
  .option("--vstroke <value>", "default stroke for cities", "none")
  .parse(process.argv);

var reader = read(commander.args[0], writeTopology).then(end).catch(abort),
  writer = write(commander.out),
  path = d3.geoPath().pointRadius(function (d) {
    var p = d.properties, v;
    return p && (v = p["point-radius"] || p.pointRadius) != null ? v : commander.radius;
  }),
  render = path;


writer.write(`
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by carte-departements. -->
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="${commander.width}" height="${commander.height}"
  ${commander.fill !== "black" ? " fill=\"" + attr(commander.fill) + "\"" : ""}
  ${commander.stroke !== "none" ? " stroke=\"" + attr(commander.stroke) + "\"" : ""}
  viewBox="0 0 ${commander.width} ${commander.height}"
>
  <defs>
    <g id="ville">
      <circle cx="0" cy="0" r="${commander.radius}" fill="${commander.vfill}" stroke="${commander.vstroke}" />
    </g>
  </defs>`.trim()
);

function end() {
  return writer.write("</svg>" + os.EOL);
}

function abort(error) {
  console.error(error.stack);
}


function attr(string) {
  return string.replace(/"/g, "&quot;");
}

function handleEpipe(error) {
  if (error.code === "EPIPE" || error.errno === "EPIPE") {
    process.exit(0);
  }
}

function read(file, callback) {
  var index = -1,
    input = file === "-" ? process.stdin : fs.createReadStream(file);

  function callbackObject(object) {
    return callback(object, ++index);
  }

  return new Promise(function (resolve, reject) {
    var data = [];
    input
      .on("data", function (d) {
        data.push(d);
      })
      .on("end", function () {
        resolve(JSON.parse(Buffer.concat(data)));
      })
      .on("error", reject);
  }).then(callbackObject);
}

function write(file) {
  var output = (file === "-" ? process.stdout : fs.createWriteStream(file)).on("error", handleEpipe),
    queue = Promise.resolve();
  return {
    write: function (data) {
      return queue = queue.then(function () {
        return new Promise(function (resolve, reject) {
          output.write(data, function (error) {
            if (error) reject(error);
            else resolve();
          });
        });
      });
    },
    end: function () {
      if (output === process.stdout) return queue;
      return queue = queue.then(function () {
        return new Promise(function (resolve, reject) {
          output.end(function (error) {
            if (error) reject(error);
            else resolve();
          });
        });
      });
    }
  };
}


async function writeTopology(topology) {
  let v;
  let features = Object.keys(topology.objects).reduce(
    (p, f) => (p[f] = topojson.feature(topology, topology.objects[f]), p), {}
  );

  const projection = d3.geoIdentity().fitSize([commander.width, commander.height], features.frontieres);

  path.projection(projection);

  for (let name of ["frontieres", "departements"]) {

    writer.write(`
      <g id="${name}">
        <path d="${render(features[name])}" />
      </g>
    `);
  }

  const cityStream = projection.stream({
    point: (x, y) => writer.write(`<use xlink:href="#ville" x="${x}" y="${y}" />`)
  });

  writer.write('<g id="villes">');

  for (let v of features.villes.features) {
    d3.geoStream(v, cityStream);
  }

  writer.write("</g>");

}