import topojson from 'topojson';
import d3 from 'd3-geo';
import fs from "fs";
import commander from "commander";
import os from "os";

commander
  .version("1.0")
  .usage("[options] [file]")
  .description("Convertit une topologie vers un SVG")
  .option("-o, --out <file>", "output file name; defaults to “-” for stdout", "-")
  .option("-w, --width <value>", "output width", 960)
  .option("-h, --height <value>", "output height", 500)
  .option("-p, --precision <value>", "number of output digits after the decimal point", 6)
  .option("-f, --fill <value>", "default fill", "none")
  .option("-s, --stroke <value>", "default stroke", "black")
  .option("-r, --radius <value>", "default point radius", 4.5)
  .option("--vfill <value>", "default fill for cities", "black")
  .option("--vstroke <value>", "default stroke for cities", "none")
  .parse(process.argv);

var reader = read(commander.args[0], writeTopology).then(end).catch(abort),
  writer = write(commander.out);


writer.write(`
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by carte-departements. -->
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="${commander.width}" height="${commander.height}"
  ${commander.fill !== "black" ? " fill=\"" + attr(commander.fill) + "\"" : ""}
  ${commander.stroke !== "none" ? " stroke=\"" + attr(commander.stroke) + "\"" : ""}
  viewBox="0 0 ${commander.width} ${commander.height}"
>
  <defs>
    <g id="ville">
      <circle cx="0" cy="0" r="${commander.radius}" fill="${commander.vfill}" stroke="${commander.vstroke}" />
    </g>
  </defs>`.trim()
);

function end() {
  return writer.write("</svg>" + os.EOL);
}

function abort(error) {
  console.error(error.stack);
}


function attr(string) {
  return string.replace(/"/g, "&quot;");
}

function handleEpipe(error) {
  if (error.code === "EPIPE" || error.errno === "EPIPE") {
    process.exit(0);
  }
}

function read(file, callback) {
  var index = -1,
    input = file === "-" ? process.stdin : fs.createReadStream(file);

  function callbackObject(object) {
    return callback(object, ++index);
  }

  return new Promise(function (resolve, reject) {
    var data = [];
    input
      .on("data", function (d) {
        data.push(d);
      })
      .on("end", function () {
        resolve(JSON.parse(Buffer.concat(data)));
      })
      .on("error", reject);
  }).then(callbackObject);
}

function write(file) {
  var output = (file === "-" ? process.stdout : fs.createWriteStream(file)).on("error", handleEpipe),
    queue = Promise.resolve();
  return {
    write: function (data) {
      return queue = queue.then(function () {
        return new Promise(function (resolve, reject) {
          output.write(data, function (error) {
            if (error) reject(error);
            else resolve();
          });
        });
      });
    },
    end: function () {
      if (output === process.stdout) return queue;
      return queue = queue.then(function () {
        return new Promise(function (resolve, reject) {
          output.end(function (error) {
            if (error) reject(error);
            else resolve();
          });
        });
      });
    }
  };
}

function renderLayer(name, feature, path) {
  writer.write(`
      <g id="${name}">
        <path d="${path(feature)}" />
      </g>
    `);
}

function renderVilles(name, villes, projection) {
  const stream = projection.stream({point: (x, y) => writer.write(`<use xlink:href="#ville" x="${x}" y="${y}" />`)});

  writer.write(`<g id="{name}">`);
  villes.map(v => d3.geoStream(v, stream));
  writer.write("</g>");

}


async function writeTopology(topology) {
  let v;
  let features = Object.keys(topology.objects).reduce(
    (p, f) => (p[f] = topojson.feature(topology, topology.objects[f]), p), {}
  );

  const extentMetropole = [[0, 3], [8, 10]];
  const extentIDF = [[6, 0], [10, 5]];
  const extentCorse = [[8, 8], [10, 10]];

  const interp = ([x, y]) => [(0.05 + 0.9 * x)*commander.width/10, (0.05 + 0.9 * y)*commander.height/10];
  const genExtent = ([p1, p2]) => [interp(p1), interp(p2)];

  const projectionMetropole = d3.geoIdentity().fitExtent(genExtent(extentMetropole), features.metropoleExt);
  const projectionIDF = d3.geoIdentity().fitExtent(genExtent(extentIDF), features.idfExt);
  const projectionCorse = d3.geoIdentity().fitExtent(genExtent(extentCorse), features.corseExt);

  const pathMetropole = d3.geoPath(projectionMetropole);
  const pathIDF = d3.geoPath(projectionIDF);
  const pathCorse = d3.geoPath(projectionCorse);

  const zoneIDF = ["75", "77", "78", "91", "92", "93", "94", "95"];
  const zoneCorse = ["2A", "2B", "20"];

  renderLayer("metropoleInt", features.metropoleInt, pathMetropole);
  renderLayer("metropoleExt", features.metropoleExt, pathMetropole);
  renderVilles(
    "metropoleVilles",
    features.villes.features.filter(v => !zoneIDF.includes(v.properties.insee.slice(0, 2)) && !zoneCorse.includes(v.properties.insee.slice(0, 2))),
    projectionMetropole
  );

  renderLayer("corseInt", features.corseInt, pathCorse);
  renderLayer("corseExt", features.corseExt, pathCorse);
  renderVilles(
    "corseVilles",
    features.villes.features.filter(v => zoneCorse.includes(v.properties.insee.slice(0, 2))),
    projectionCorse
  );

  renderLayer("idfInt", features.idfInt, pathIDF);
  renderLayer("idfExt", features.idfExt, pathIDF);
  renderVilles(
    "idfVilles",
    features.villes.features.filter(v => zoneIDF.includes(v.properties.insee.slice(0, 2))),
    projectionIDF
  );
}